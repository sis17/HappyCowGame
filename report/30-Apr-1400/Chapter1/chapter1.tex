\chapter{Background \& Objectives}
This chapter explains the first few weeks of the project.

\section{Aim of the Project}
To begin it was important to gain an understanding of the project. This came in the form of two meetings with the client, Gabriel de la Fuente Oliver. In the first meeting an overview of the project was discussed. It was outlined that the aim of the project was to turn a board game of standard complexity into a web application. The game is educational, designed to teach students about creating food packages for cow feed. Players assemble ingredients and build food packages, which they then navigate through the cow's digestive system to experience it's effect on the cow digestion. 
	
The web application would expand the usability of the game, by publishing it in a format that can be readily played by anyone, anywhere. Some of the foreseen purposes of the application are for university lecturers, secondary school teachers, or in science fairs. Lecturers could point students to the project as a fun way of re-visiting lecture content. For secondary school teachers it could be a teaching aid, capturing a classes' imagination as they learn about rumination. In a science fair the application would become an easily portable tool to introduce the concepts behind research into better cow food.
	
The second meeting with the client involved playing the board game. This proved extremely useful, both as a way to get to know the client, and in order to gain a foundational understanding of how the game worked. This helped to begin thinking of ways to portray this physical game on a two-dimensional screen. The interest that can be sparked for an academic subject by translating it into a game was also demonstrated. While testing the game in a public place, a few curious bystanders asked what was going on, and were willing to become testers of the web application at a later stage.
	
A few key points were evident as a result of these meetings that helped pave the way for further research:
\begin{itemize}
	\item Two ways of playing the game are needed. Both the ability to play remotely across a network with players at another machine, and the option for players to gather around one machine and wait their turn. The first scenario accounts for single users who wish to learn by playing a game with friends over a period of time. The second scenario is that of the classroom or science fair where it becomes impractical for each player to have their own machine.
	\item For the above two scenarios it is necessary for the application to persist data about the state of each game. Players therefore need accounts so that they can return to games. 
	\item The game is turn-based. Players need to be told when it is their turn, and only be able to perform actions at that time.
	\item Usability is fundamental to the project. In a classroom setting, with many users time is short. A confusing game will take a long time to learn, and may therefore never have the chance to teach the information it was designed to. The application must therefore present a game that is easy to pick up with no prior knowledge. For that the user interface must be clean and instructive, prompting a user as to what their next action should be.
\end{itemize}

\section{Research}
With these key points in mind, the project entered a research phase, a search to find the best platform or technologies to carry the work forward.
	
Hundreds of possible technologies are available for web development. The first point of entry into this maze was to examine existing work in game development specifically. Perhaps this would lead to some work or platform where many of the necessary features for a turn-based board game are already in place.

\subsection{Existing Game Platforms}
HTML5 game development is a booming industry, as \cite{BrowserGames} demonstrate. This category of games runs almost entirely in the client's browser, and replicates jumping, running, and shooting type games. Some turn based games exist, but the emphasis remains on playing in real time with users across a network, or against artificial intelligence. Platforms such as Tizen \cite{Tizen} are designed to make these games easier to develop, and focuses on mobile app development. Help to develop HTML5 games by Mozilla \cite{GameEngAndTools, GameDevCons} suggests that any persistence of data can be done in the browser, or using Google Play \cite{GooglePlay}. The focus of these games is user control, clicking or reacting at the right time. In the eyes of many developers, web-based game development is analogous to HTML5 games.
	
The aim of this project, however, is to create a web application from a board game. Board games are a different league of games. The focus is strategy, so users make relatively few button click actions. This type of game was much less common, with no standard approach or platform used to develop it. Yet two platforms are worth noting, to demonstrate how they did not fit the requirements of the project.
	
Vassal is an open source game engine. Players download the software, choose a game from a list of modules and then play across a network using the dedicated Vassal server, or via email. Hundreds of games exist as modules, and users can create a new game as a module using a Vassal Editor service \cite{Vassal}. However, the Vassal game engine treats a game as an actual board game in that no game rules are enforced. As when sitting around a board, players are expected to know and confine themselves to the rules, and adjust game pieces at the right times \cite{VassalProblem}. This feature makes Vassal an inadequate engine for this project. Confining players, so they must follow the rules, is one way of teaching the rules of a game. A game presents a steeper learning curve if players must learn and keep the rules while they play.
	
Another platform is the Board Game Arena \cite{BGAStudio}. Again it provides a server which allows players to join a waiting room, and then begin a game together. Unlike Vassal it requires and supports rule enforcement. However, it focuses on real time play, where players are expected to finish a game in one sitting. More importantly, a big disadvantage is that the development environment is fairly basic. The game engine is built using PHP, and provides method hooks for persisting data, and getting user information. Beyond that, however, no support seems to be given, and object oriented development is complicated by the engine not encouraging it. Most importantly, very little documentation could be found, and much of the user community comments were a few years out of date.
	
These were the open source versions. Various proprietary solutions existed for a price \cite{PhotonEngine, Cocos2DX, LearnCocos2D}. It seems that board game engines, which enforce game rules, are fairly new and immature. In contrast to this, frameworks for CRUD web applications abound. They do not focus on game development specifically, but user communities are large, and the frameworks have been in use for many years, giving time for them to mature. A Ruby on Rails \cite{Rails} application supports user authentication, and data persistence. The only shortcoming of standard web applications is that they are designed to present resources rather than an continuous game environment. Research was therefore necessary to learn what practices exist for building games using standard web application technologies.

\subsection{Web-Application Frameworks}
Single Page Applications (SPA) is a hot term among web developers. An SPA is an application that relies on a client side framework to update page content instead of relying on a page refresh \cite{SPABook}. Some SPAs behave like a traditional website only using the client side framework to more quickly load data \cite{DevBBoneApps}, whereas other SPAs display content differently. Instead of content being split into identifiable resources, data is searched and displayed uniquely. An example is Google Maps \url{google.co.uk/maps}. This approach better fits the requirements for a board game. Users should remain on the same screen, as though they were around a board, while and assortment of only loosely connected information is automatically updated in the same space to reflect their actions.
	
SPA development is built on top of basic Ajax requests and DOM manipulation. But whereas websites have been using these technologies for many years to make small changes to data, an SPA is built around asynchronous requests and DOM updates, and therefore requires a more sophisticated structure to prevent the application culminating in a headache of un-trackable code.
	
That is where the client side Model View Controller comes in. Previously the MVC pattern gave structure to server applications. When building even small applications is helps to follow a proven pattern, and the MVC pattern has been shown to reduce complexity by separating concerns. Within server side implementations many differences exist \cite{CompareFrWrks}, but the basic idea remains the same: the data should not know how it is being displayed. If it does, it will become hard to maintain, and create implementation nightmares further down the development line.
	
If the MVC pattern works so well on server side frameworks, why not build a client side framework that does the same? The developers of these new frameworks, however, prefer to call what they are doing the MV* pattern. When moving from the server to the client the C for Controller becomes muddy ground. Whereas on the server it translates incoming requests with URLs to the appropriate action, grabs data in the form of models and renders the correct view, in the client side framework the controller's job is much more demanding. Delayed Ajax results, user clicks, and DOM changes all need to be resolved differently \cite{SPABook}. A better term for controllers may be 'glue' or some other description. Hence the term MV* \cite{DevBBoneApps}.
	
There are three often quoted Javascript client side frameworks that follow an MV* pattern: BackboneJS \cite{BBoneJS}, EmberJS \cite{Ember} and AngularJS \cite{AngularJS}. They all rely on the application data as the model, and inject templates into the DOM which is treated as the view. The differences between them is in the 'glue'.
	
For this project I considered BackboneJS and AngularJS, as they have perhaps the largest contrast. Backbone was the first of the two frameworks on the scene, and it's name explains it's attitude to the problem. It is a lightweight solution, meaning it does not make assumptions or try and force developers to use a particular style, but it does give the bare bones of a helpful structure. If followed it can reduce the complexity in a project by setting up event listeners to automatically refresh the view or update the model in an expected way \cite{DevBBoneApps}.
	
AngularJS takes a different approach. It came later and is an attempt to abstract away the need for defining models, views, or event listeners at all. The DOM is treated as the view, and controlled by HTML attributes. The model is any data attached to the scope of the DOM element, if the model changes, the scope automatically updates the view. It is a novel approach, that separates itself from the world of JQuery, yet it is efficient to use and has therefore been widely adopted \cite{AngOverBB}.
	
Backbone is easier to understand, but Angular aims for convention over configuration, in other words, if you know how it works, it becomes quicker to write. Less code means less to maintain. The current project requires many interacting view templates. Using Backbone, all the event listeners and mini-controllers would need to be set up manually. With Angular less configuration is needed. Once development with Angular becomes a familiarity, implementing the  functionality of the game will take less time. On top of this the Angular community is vibrant. Plug-ins for almost anything the core Angular does not provide are readily available. Most noticeably Angular was designed with unit and end-to-end testing in mind \cite{Angular}. The luxury of easily creating tests was a large attraction.
	
To use a client framework such as AngularJS makes expectations of the application that will serve the data. After the initial page loads, the user will never see data in the state it arrives from the server. Instead data will be used as a model and injected into the view by the client software \cite{SPABook}. It is therefore not important for the server to work like a game at all. All resemblances of a game are created by the client. It is important rather that the server provide access to data the client will need, and to organise the data in such a way as it is quickly retrieved and parsed. Two common options for this are JSON or XML. In other words, interoperability is needed between two machines. This is beginning to sound like the domain of a REST protocol.
	
There are many server side frameworks which serve a RESTful API, but the one most commonly mentioned \cite{BestSerPlat} is Ruby on Rails.
	
A simple understanding of the problem led to guided research. The research showed what was possible, and the most beaten tracks for creating web applications. Developing a SPA with well documented frameworks was the most dependable approach. If a SPA was required, then AngularJS sitting on top of a RESTful API served by Ruby on Rails would make sure the project was in good company. Testing on both the server and client frameworks are assumed and supported.

\section{Analysis}
Knowing the technologies to use are all very well, but what about the project itself? Analysis of the game specific requirements were gathered from existing game rules, provided by the client. 
	
\subsection{Existing Game Rules}
Converting the rules into requirements meant taking sentences which defined a rule of the game and describing it as a task in a new sentence as succinctly as possible. These tasks are described in Appendinx B. These tasks fitted naturally into two sections. The first defined the flow of the game, how turns passed within a round and the different phases that allowed certain actions. The second section was concerned with game artefacts such as rules for cards, food rations, or different sections of the cow's digestive system.
	
A card phase and movement phase were defined by the board game. As well as these, the requirement analysis identified a need for two extra phases, an events phase at the beginning of a round for users to review an occurring event, and a review phase allowing users to see actions taken by other players and the current score of the game. The review phase helps players to see what has happened when they play the game across a network, because another player's actions are hidden.
	
An example of this decomposition of rules to tasks is the rule that players cannot have more than nine cards. That makes sense, but it was the job of the requirements analysis to specify how that would work in a few tasks and when it would be checked within the application. In section 4.3.4, two tasks explain: 
	\begin{enumerate}
		\item If the player has fewer than 9 cards, they can end their turn. The next player in order then becomes active. 
		\item If the player has more than 9 cards, they must first discard cards until they have 9. 
	\end{enumerate}
These two rules have broken down the problem into more easily programmed and testable problems by specifying when the card number will be checked, and what the result will be.

After the game rules were represented this way, many tasks concerned with the running of the application still needed defining. These include registering users, authenticating users, a profile page for users to manage their details, communication between players, how to set up games, who can delete a game, and how to display a list of games for a user. To adequately cover these requirements, each of the sections mentioned was broken down into two to five sub points, with the main features required.
	
	For example, the section describing the list of games for a user details the following:
	\begin{itemize}
		\item Each player can view a games board, showing all the games they are in, or have been involved in. 
		\item Each game will show the players and score of the game. 
		\item From here a player can select a game, and if it is in progress they are taken to the game play screen.
		\item If a game is finished, players can view statistics of the game. And a game history.
	\end{itemize}

\subsection{Usability}
An important aspect of the project is usability. The client agreed that this was important enough to include tasks to ensure it happens in the requirements analysis. These requirements included tasks such as alerts which provide feedback for users, updating information about the cow, and more complicated rules of the game that are not essential for playing the game. Testing requirements were added because of this. It was concluded that the game should work using Internet Explorer, as this remains a prevalent browser in education, and that testing should be done in the other major browsers as well. The need for a tutorial for the game, and a feedback form for users to say what they would like to see changed were also registered as 'nice to have' features.
	
Another requirement resulting from the game being published as a web application was crowd games. There are two types of scenarios in which the game can be played, they are labelled in the requirements analysis as persistent games and crowd games. Consider a user who wishes to play a game with his friend across the internet. They will log into different machines, yet want to play the same game. The game needs to store their details, as one player may logout to make a cup of tea and then wish to pick the game up again.
	
Another scenario is the science fair, also a required use of the game. In this case it would be a hassle to provide a different machine for each player. Instead, all the players want to gather around a single machine and take turns making choices. These games are known as crowd games. The game simply changes the authenticated player and lets everyone know whose turn it is next. In this scenario authentication must be done when the game begins, so players don't have to login every turn. It is also much less likely that players will want to re-continue a game, it would mean everyone must get together again.
	
The set up for these two games is also different. In the first the game has a creator who invites other players, in the second everyone creates the game together. The set up conditions do not need to persist as players will start the game there and then.
	 
In the case of a teacher using the game in a classroom setting, either the persistent or crowd scenario could be used, depending on whether each student has access to their own machine.
	
While crowd games do not need players to register, and the game details do not need to be persisted, for the scope of this project these things must happen. This is because as far as possible, the persistent games and crowd games are the same, to minimise the need for extra features. Including both of these games in the requirement analysis was helpful for the design of the application. From the beginning both games were expected, so design decisions could be made with that in view.

\subsection{Development Phases}
The first draft of the requirements analysis treated all tasks as equals. Yet more work was listed than could be realistically completed. This lead to another important part of the requirements analysis, which was dividing the tasks into four development phases. 
	
A core phase was created to hold tasks that were essential to the use of the application. This phase would need to be completed before the game could be played and any usability testing could begin. It includes tasks such as logging in, setting up a game, using cards to build food rations and moving food rations through the cow.
	
A second phase was created called the usability phase. This phase included tasks which were not essential for functional game play, but made the game easier to learn, and helped players see what was going on. This also included the registration of players, and a page for them to edit their details.
	
The third phase referred to tasks necessary for crowd games. Because of the significant differences between the persistent and crowd games, many tasks were necessary for just the crowd games to be possible. This led to designating the persistent game as the default game type. It would be created first. The crowd game would be included in the design, but not implemented until the first two phases were complete.
	
The final phase gathered up the rest of the tasks in an enhancement phase. This included all tasks which were not realistically expected to be developed during the scope of this project.
	
The break up of tasks into phases was fairly straight forward as they had already been defined, yet it was a huge success in the development of the project. It gave a rough guide as to the order of development. Without the distinction of phases, there may have been less agreement as to the order of development in later stages of the project.


\section{Development Methodologies}
There are two main camps of project development methodologies: agile and plan based. In the agile league a whole variety of reasonably similar methods are available, Extreme Programming, Scrum, Feature Driven Development (FDD) are the biggest players. For plan based methodologies there is the Waterfall approach, with strict categories of development that flow from one to the other until the project is finished.
	
The distinction between methodologies is often not altogether clear. While aspects of a particular method may be attractive or useful for a project, other practices may not apply and actually end up hampering development. Yet at the same time, it is important to be disciplined in the chosen methodology. Many methodologies fail if developers only play lip service to the practices they outline and do not fulfil them. Here several main methodologies will be considered, and an argument for the chosen process for this project will be presented.
	
Extreme Programming (XP) is a popular methodology, and is often the favourite among developers using Rails or Agile frameworks. It uses a series of strict practices designed to reduce the need for planning at the beginning of a project, by implementing automated tests, pair programming, and a schedule of team meetings to make sure the vision for the project is communicated mouth to mouth and understood by everyone. It is a valid approach practised successfully by many teams around the world \cite{XP}.
	
However, there are disadvantages with one developer. Many of XP's practices are designed for projects with a team of three to seven, pair programming especially is challenging with just one developer. It also requires a large amount of discipline. Automated testing is crucial, as with many small releases the developers need to know if a new feature has created an issue. Where project details are not well defined to begin with it is difficult to make a design, and so XP works well. If details are understood, however, perhaps time could be saved with planning core elements of a project to begin with.
	
FDD is designed to fit larger projects than XP. It does this by accepting a need for written documentation of features. These are planned by the development teams that will carry them out, and relayed and checked by the architects of the project. FDD also provides a simple system of monitoring project progress for large teams, it can fairly accurately work out the percentage of tasks that are complete. However, FDD is designed for large development teams, and so is not applicable to this project.
	
Scrum is the simplest methodology. It only specifies sprints, which are blocks of time which a team takes to implement a number of features before reuniting with management to review the work completed and discuss how to make the next sprint more successful. Scrum does not require a certain amount of people, but is more of a discipline to demand that periodic reviews of a project are taken. In scrum honesty about the challenges a team encounters, and explaining these to the project client are more important than meeting deadlines. Aspects of this match the project at hand.
	
Finally, a plan based methodology follows a strict structure, and goes through a recognised number of stages. First a requirements phase seeks to work out what needs to be done. Areas of the project are broken down into small tasks that can be listed and ticked off as the project progresses. Once requirements are gathered, a design specification is drawn up. The aim of this document is to outline for the development team what each area of the software will accomplish so that different developers can work on parts of the project in isolation. When the design is complete, development begins. It is checked when complete, and then a team of testers search for issues with the project to ascertain if it is worthy of deployment.
	
The challenge is to find a methodology that fits a project with one developer. While XP and FDD have many practices that do not work, Scrum and a plan based approach are more adaptable to one person. In the current project, constant access to the client was not possible. After the initial two meetings the client moved to a different country. A more agile methodology require such access, and was therefore impractical. Furthermore the requirements of the project were fairly well understood because the game already existed as a board game, with instructions. Defining requirements analysis, and developing an upfront design were therefore quite feasible with the information I had.
	
The development methodology used for the project, therefore, was plan based, with an iterative development phase later giving way to testing and maintenance. This meant that early on documentation could be produced that the client could check. When development got under way, weekly meetings with the client were possible. A review of the work done, and discussion of the most important features to work on next became a weekly cycle. In this phase of the project the process was therefore similar to Scrum. After development, usability testing and automated tests were run, and the client played less of a role.

